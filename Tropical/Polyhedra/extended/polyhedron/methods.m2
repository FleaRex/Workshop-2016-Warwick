 -- PURPOSE : Computing the smallest face of 'P' containing 'p'
--   INPUT : '(p,P)',  where 'p' is a point given as a matrix and
--     	    	       'P' is a polyhedron
--  OUTPUT : The smallest face containing 'p' as a polyhedron
smallestFace = method()
smallestFace(Matrix,Polyhedron) := (p,P) -> (
     -- Checking for input errors
     if numColumns p =!= 1 or numRows p =!= ambDim(P) then error("The point must lie in the same space");
     -- p = chkZZQQ(p,"point");
     -- Checking if 'P' contains 'p' at all
     if contains(P,convexHull p) then (
	      (M,v) := halfspaces P;
     	   (N,w) := hyperplanes P;
     	  -- Selecting the half-spaces that fullfil equality for p
	  -- and adding them to the hyperplanes
	  v = promote(v,QQ);
	  pos := select(toList(0..(numRows M)-1), i -> (M^{i})*p == v^{i});
	  N = N || M^pos;
	  w = w || lift(v^pos,ZZ);
	  intersection(M,lift(v,ZZ),N,w))
     else emptyPolyhedron ambDim(P))



-- PURPOSE : Checks if the polytope is normal
--   INPUT : 'P'  a Polyhedron, which must be compact
--  OUTPUT : 'true' or 'false'
-- COMMENT : The polytope is normal if the lattice of the cone over the polytope embedded on height 1 
--     	     is generated by the lattice points on height 1
isNormal Polyhedron := P -> getProperty(P, computedNormal)


-- PURPOSE : Computing the Ehrhart polynomial of a polytope
--   INPUT : 'P',  a polyhedron which must be compact, i.e. a polytope
--  OUTPUT : A polynomial in QQ[x], the Ehrhart polynomial
-- COMMENT : Compactness is checked within latticePoints
ehrhart = method(TypicalValue => RingElement)
ehrhart Polyhedron := P -> getProperty(P, computedEhrhart)


-- PURPOSE : Computing the polar of a given polyhedron
--   INPUT : 'P',  a Polyhedron
--  OUTPUT : A Polyhedron, the set { v | v*p<=1 forall p in P}
polar = method(TypicalValue => Polyhedron)
polar Polyhedron := P -> getProperty(P, computedPolar)


-- PURPOSE : Checks if a polytope is very ample
--   INPUT : 'P'  a Polyhedron, which must be compact
--  OUTPUT : 'true' or 'false'
isVeryAmple = method()
isVeryAmple Polyhedron := P -> getProperty(P, computedVeryAmple)


-- PURPOSE : Computing the vertex-edge-matrix of a polyhedron
--   INPUT : 'P',  a polyhedron
--  OUTPUT : a matrix, where the columns are indexed by the edges and the rows indexed by the vertices and has 1 as entry
--           if the corresponding edge contains this vertex
vertexEdgeMatrix = method(TypicalValue => Matrix)
vertexEdgeMatrix Polyhedron := P -> (
   -- list the edges and the vertices
   eP := apply(faces(dim P -1,P), f -> f#0);
   nEdge := #eP;
   nVert := numColumns vertices P;
   result := map (ZZ^nVert, ZZ^nEdge, 0);
   result = (matrix {{1..nEdge}}) || result;
   result = (transpose matrix {{0..nVert}}) | result;
   result = mutableMatrix result;
   i := 0;
   for edge in eP do (
      s := edge#0;
      t := edge#1;
      result_(s + 1, i + 1) = 1;
      result_(t + 1, i + 1) = 1;
      i = i+1;
   );
   matrix result
)


-- PURPOSE : Computing the vertex-facet-matrix of a polyhedron
--   INPUT : 'P',  a polyhedron
--  OUTPUT : a matrix, where the columns are indexed by the facets and the rows are indexed by the vertices and has 1 as entry
--           if the corresponding facet contains this vertex
vertexFacetMatrix = method(TypicalValue => Matrix)
vertexFacetMatrix Polyhedron := P -> (
   -- list the facets and the vertices
   fP := apply(faces(1,P), f -> f#0);
   nFacet := #fP;
   nVert := numColumns vertices P;
   result := map (ZZ^nVert, ZZ^nFacet, 0);
   result = (matrix {{1..nFacet}}) || result;
   result = (transpose matrix {{0..nVert}}) | result;
   result = mutableMatrix result;
   i := 0;
   for facet in fP do (
      for v in facet do (
         result_(v + 1, i + 1) = 1;
      );
      i = i+1;
   );
   matrix result
)


-- PURPOSE : Computing the face fan of a polytope
--   INPUT : 'P',  a Polyhedron, containing the origin in its interior
--  OUTPUT : The Fan generated by the cones over all facets of the polyhedron
faceFan = method(TypicalValue => Fan)
faceFan Polyhedron := P -> (
   -- Checking for input errors
   if not inInterior(map(QQ^(ambDim P),QQ^1,0),P) then  error("The origin must be an interior point.");
   if not isCompact P then error("Polyhedron must be compact");
   resultRays := vertices P;
   resultCones := faces(1, P);
   resultCones = apply(resultCones, c -> c#0);
   fan(resultRays, resultCones)
)


-- PURPOSE : Computing the cell decomposition of a compact polyhedron given by a weight vector on the lattice points
--   INPUT : '(P,w)',  where 'P' is a compact polyhedron and 'w' is a one row matrix with with lattice points of 'P' 
--     	    	       many entries
--  OUTPUT : A list of polyhedra that are the corresponding cell decomposition
cellDecompose = method(TypicalValue => List)
cellDecompose (Polyhedron,Matrix) := (P,w) -> (
   n := dim P;
   LP := latticePoints P;
   -- Checking for input errors
   if numColumns w != #LP or numRows w != 1 then error("The weight must be a one row matrix with number of lattice points many entries");
   LP = matrix{LP}||w;
   P = convexHull(LP,matrix (toList(dim P:{0})|{{1}}));
   A := map(QQ^n,QQ^n,1) | map(QQ^n,QQ^1,0);
   flatten apply(facesAsPolyhedra(1,P), f -> if isCompact f then affineImage(A,f) else {})
)


--   INPUT : 'P',  a polyhedron,
--  OUTPUT : A matrix, a basis of the sublattice spanned by the lattice points of 'P'
sublatticeBasis Polyhedron := P -> (
     L := latticePoints P;
     -- Checking for input errors
     if L == {} then error("The polytope must contain lattice points.");
     -- Translating 'P' so that it contains the origin if it did not already
     if all(L,l -> l != 0) then L = apply(L, l -> l - L#0);
     sublatticeBasis(matrix {L}))
   
-- PURPOSE : Calculating the preimage of a polytope in the sublattice generated by its lattice points
--   INPUT : 'P',  a polyhedron
--  OUTPUT : A polyhedron, the projected polyhedron, which is now normal
toSublattice = method()
toSublattice Polyhedron := P -> (
     L := latticePoints P;
     -- Checking for input errors
     if L == {} then error("The polytope must contain lattice points.");
     b := L#0;
     -- Translating 'P' so that it contains the origin if it did not already
     if all(L,l -> l != 0) then L = apply(L, l -> l - L#0);     
     affinePreimage(sublatticeBasis matrix {L},P,b))


-- PURPOSE : Compute the corresponding face of the polar polytope
--   INPUT : 'P',  a Polyhedron
--  OUTPUT : A Polyhedron, if 'P' is the face of some polyhedron 'Q' then the
--     	     result is the dual face on the polar of 'Q'. If 'P' is not a face
--           then it is considered as the face of itself and thus the 
--           polarFace is the empty Polyhedron
polarFace = method(TypicalValue => Polyhedron)
polarFace(Polyhedron, Polyhedron) := (f, P) -> (
   if not isFace(f, P) then error("First polyhedron should be face of second.");
   if f == P then return emptyPolyhedron dim f;
   --local faceOf;
   V := transpose vertices f;
   R := transpose rays f;
   Pd := polar P;
   codimensionfd := dim f - (numColumns linealitySpace P) + 1;
   L := facesAsPolyhedra(codimensionfd, Pd);
   Pd = first select(1,L, l -> all(flatten entries(V*(vertices l)),e -> e == -1) and V*(rays l) == 0 and R*(vertices l | rays l) == 0);
   Pd
)	       
